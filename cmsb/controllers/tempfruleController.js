const ErrorHander = require("../utils/errorhander");
const catchAsyncErrors = require("../middleware/catchAsyncErrors");
const tempFrule = require("../models/tempfRulesModel");
const Frule = require("../models/fRulesModel");

// Register a tempFrule
exports.registerFrule = catchAsyncErrors(async (req, res, next) => {
  let mes = `Firewall rule added successfully.`;
  const checkFrule = await Frule.findOne({ ruleId: req.body.ruleId });
  const tempCheckFrule = await tempFrule.findOne({ ruleId: req.body.ruleId });
  var totalRulesWithSpecificIdAndVersion = await tempFrule.countDocuments({
    deviceId: req.body.deviceId,
    ruleId: req.body.ruleId,
  });
  if (req.user.role === "Admin") {
    if (!tempCheckFrule) {
      const {
        ruleId,
        deviceId,
        rtype,
        action,
        disabled,
        quick,
        interface,
        direction,
        addressFamily,
        protocol,
        icmpSubtypes,
        sInvertMatch,
        sAny,
        sAddress,
        sPort,
        sprFrom,
        sprFromCustom,
        sprTo,
        sprToCustom,
        dInvertMatch,
        dAny,
        dAddress,
        dPort,
        dptFrom,
        dptFromCustom,
        dptTo,
        dptToCustom,
        log,
        description,
        sourceOs,
        diffservCodePoint,
        allowIpOptions,
        disableReplyTo,
        tag,
        tInvert,
        tagged,
        maxState,
        maxSrcNodes,
        maxConnections,
        maxSrcStates,
        maxSrcConnRate,
        maxSrcConnRateS,
        stateTimeout,
        setFin,
        setSyn,
        setRst,
        setPsh,
        setAck,
        setUrg,
        setEce,
        setCwr,
        outofFin,
        outofSyn,
        outofRst,
        outofPsh,
        outofAck,
        outofUrg,
        outofEce,
        outofCwr,
        tcpAnyFlag,
        noPfsync,
        stateType,
        noXmlrpcSync,
        vlanPrio,
        vlanPrioSet,
        gateway,
        generatedByUserId,
      } = req.body;

      const tempfrule = await tempFrule.create({
        ruleId,
        deviceId,
        rtype,
        action,
        disabled,
        quick,
        interface,
        direction,
        addressFamily,
        protocol,
        icmpSubtypes,
        sInvertMatch,
        sAny,
        sAddress,
        sPort,
        sprFrom,
        sprFromCustom,
        sprTo,
        sprToCustom,
        dInvertMatch,
        dAny,
        dAddress,
        dPort,
        dptFrom,
        dptFromCustom,
        dptTo,
        dptToCustom,
        log,
        description,
        sourceOs,
        diffservCodePoint,
        allowIpOptions,
        disableReplyTo,
        tag,
        tInvert,
        tagged,
        maxState,
        maxSrcNodes,
        maxConnections,
        maxSrcStates,
        maxSrcConnRate,
        maxSrcConnRateS,
        stateTimeout,
        setFin,
        setSyn,
        setRst,
        setPsh,
        setAck,
        setUrg,
        setEce,
        setCwr,
        outofFin,
        outofSyn,
        outofRst,
        outofPsh,
        outofAck,
        outofUrg,
        outofEce,
        outofCwr,
        tcpAnyFlag,
        noPfsync,
        stateType,
        noXmlrpcSync,
        vlanPrio,
        vlanPrioSet,
        gateway,
        generatedByUserId,
        version: totalRulesWithSpecificIdAndVersion,
      });
    } else {
      mes = "Error: Duplicate Rule Id Entered";
    }
  } else if (req.user.role === "Operator") {
    if (!checkFrule && !tempCheckFrule) {
      const {
        ruleId,
        deviceId,
        rtype,
        action,
        disabled,
        quick,
        interface,
        direction,
        addressFamily,
        protocol,
        icmpSubtypes,
        sInvertMatch,
        sAny,
        sAddress,
        sPort,
        sprFrom,
        sprFromCustom,
        sprTo,
        sprToCustom,
        dInvertMatch,
        dAny,
        dAddress,
        dPort,
        dptFrom,
        dptFromCustom,
        dptTo,
        dptToCustom,
        log,
        description,
        sourceOs,
        diffservCodePoint,
        allowIpOptions,
        disableReplyTo,
        tag,
        tInvert,
        tagged,
        maxState,
        maxSrcNodes,
        maxConnections,
        maxSrcStates,
        maxSrcConnRate,
        maxSrcConnRateS,
        stateTimeout,
        setFin,
        setSyn,
        setRst,
        setPsh,
        setAck,
        setUrg,
        setEce,
        setCwr,
        outofFin,
        outofSyn,
        outofRst,
        outofPsh,
        outofAck,
        outofUrg,
        outofEce,
        outofCwr,
        tcpAnyFlag,
        noPfsync,
        stateType,
        noXmlrpcSync,
        vlanPrio,
        vlanPrioSet,
        gateway,
        generatedByUserId,
      } = req.body;

      const tempfrule = await tempFrule.create({
        ruleId,
        deviceId,
        rtype,
        action,
        disabled,
        quick,
        interface,
        direction,
        addressFamily,
        protocol,
        icmpSubtypes,
        sInvertMatch,
        sAny,
        sAddress,
        sPort,
        sprFrom,
        sprFromCustom,
        sprTo,
        sprToCustom,
        dInvertMatch,
        dAny,
        dAddress,
        dPort,
        dptFrom,
        dptFromCustom,
        dptTo,
        dptToCustom,
        log,
        description,
        sourceOs,
        diffservCodePoint,
        allowIpOptions,
        disableReplyTo,
        tag,
        tInvert,
        tagged,
        maxState,
        maxSrcNodes,
        maxConnections,
        maxSrcStates,
        maxSrcConnRate,
        maxSrcConnRateS,
        stateTimeout,
        setFin,
        setSyn,
        setRst,
        setPsh,
        setAck,
        setUrg,
        setEce,
        setCwr,
        outofFin,
        outofSyn,
        outofRst,
        outofPsh,
        outofAck,
        outofUrg,
        outofEce,
        outofCwr,
        tcpAnyFlag,
        noPfsync,
        stateType,
        noXmlrpcSync,
        vlanPrio,
        vlanPrioSet,
        gateway,
        generatedByUserId,
        version: totalRulesWithSpecificIdAndVersion,
      });
    } else {
      mes = "Error: Duplicate Rule Id Entered";
    }
  }
  res.status(200).json({
    success: true,
    message: mes,
  });
});

// Get all frules(admin)
exports.getAllFrules = catchAsyncErrors(async (req, res, next) => {
  const frules = await tempFrule.find();

  res.status(200).json({
    success: true,
    message: "Firewall rules fetched successfully",
    frules,
  });
});

// Get single tempfrule (admin)
exports.getSingleFrule = catchAsyncErrors(async (req, res, next) => {
  const tempfrule = await tempFrule.findOne({
    ruleId: req.body.ruleId,
    version: req.body.version,
  });

  if (!tempfrule) {
    return next(
      new ErrorHander(
        `Firewall rule does not exist with Rule Id : ${req.body.ruleId}`
      )
    );
  }
  res.status(200).json({
    success: true,
    tempfrule,
  });
});

// update tempFrule  -- Admin
exports.updateFrule = catchAsyncErrors(async (req, res, next) => {
  var totalRulesWithSpecificIdAndVersion = await tempFrule.countDocuments({
    deviceId: req.body.deviceId,
    ruleId: req.body.ruleId,
  });
  const {
    ruleId,
    deviceId,
    rtype,
    action,
    disabled,
    quick,
    interface,
    direction,
    addressFamily,
    protocol,
    icmpSubtypes,
    sInvertMatch,
    sAny,
    sAddress,
    sPort,
    sprFrom,
    sprFromCustom,
    sprTo,
    sprToCustom,
    dInvertMatch,
    dAny,
    dAddress,
    dPort,
    dptFrom,
    dptFromCustom,
    dptTo,
    dptToCustom,
    log,
    description,
    sourceOs,
    diffservCodePoint,
    allowIpOptions,
    disableReplyTo,
    tag,
    tInvert,
    tagged,
    maxState,
    maxSrcNodes,
    maxConnections,
    maxSrcStates,
    maxSrcConnRate,
    maxSrcConnRateS,
    stateTimeout,
    setFin,
    setSyn,
    setRst,
    setPsh,
    setAck,
    setUrg,
    setEce,
    setCwr,
    outofFin,
    outofSyn,
    outofRst,
    outofPsh,
    outofAck,
    outofUrg,
    outofEce,
    outofCwr,
    tcpAnyFlag,
    noPfsync,
    stateType,
    noXmlrpcSync,
    vlanPrio,
    vlanPrioSet,
    gateway,
    generatedByUserId,
  } = req.body;
  const tempfrule = await tempFrule.findOne({ ruleId: req.body.ruleId });
  if (!tempfrule) {
    return next(
      new ErrorHander(
        `Firewall rule does not exist with Rule Id : ${req.params.ruleId}`
      )
    );
  }
  await tempFrule.create({
    ruleId,
    deviceId,
    rtype,
    action,
    disabled,
    quick,
    interface,
    direction,
    addressFamily,
    protocol,
    icmpSubtypes,
    sInvertMatch,
    sAny,
    sAddress,
    sPort,
    sprFrom,
    sprFromCustom,
    sprTo,
    sprToCustom,
    dInvertMatch,
    dAny,
    dAddress,
    dPort,
    dptFrom,
    dptFromCustom,
    dptTo,
    dptToCustom,
    log,
    description,
    sourceOs,
    diffservCodePoint,
    allowIpOptions,
    disableReplyTo,
    tag,
    tInvert,
    tagged,
    maxState,
    maxSrcNodes,
    maxConnections,
    maxSrcStates,
    maxSrcConnRate,
    maxSrcConnRateS,
    stateTimeout,
    setFin,
    setSyn,
    setRst,
    setPsh,
    setAck,
    setUrg,
    setEce,
    setCwr,
    outofFin,
    outofSyn,
    outofRst,
    outofPsh,
    outofAck,
    outofUrg,
    outofEce,
    outofCwr,
    tcpAnyFlag,
    noPfsync,
    stateType,
    noXmlrpcSync,
    vlanPrio,
    vlanPrioSet,
    gateway,
    generatedByUserId,
    version: totalRulesWithSpecificIdAndVersion,
  });

  res.status(200).json({
    success: true,
    message:
      "Firewall Rule Updated Successfully and is waiting for Admin approval.",
  });
});

// Delete tempFrule --Admin
exports.deleteFrule = catchAsyncErrors(async (req, res, next) => {
  const tempfrule = await tempFrule.findOne({ ruleId: req.params.ruleId });

  if (!tempfrule) {
    return next(
      new ErrorHander(
        `Firewall rule does not exist with Rule Id : ${req.params.ruleId}`,
        400
      )
    );
  }
  await tempFrule.deleteMany({ ruleId: req.params.ruleId });

  res.status(200).json({
    success: true,
    message:
      "Firewall Rule Deleted Successfully and is waiting for Admin approval.",
  });
});
